/**
 * Author : GÃ©rald FENOY
 *
 * Copyright 2008-2009 GeoLabs SARL. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


#include "service.h"
#include "service_internal.h"
#include "sshapi.h"

#include <sys/socket.h>
#include <sys/un.h>

#include <libxml/tree.h>
#include <libxml/parser.h>
#include <libxml/xpath.h>
#include <libxml/xpathInternals.h>

#include <libxslt/xslt.h>
#include <libxslt/xsltInternals.h>
#include <libxslt/transform.h>
#include <libxslt/xsltutils.h>

#include <dirent.h>
extern "C" {

  /**
   * FinalizeHPC ZOO Service :
   * This service is used to inform a ZOO-Kernel waiting for the end of the
   * execution of a HPC service
   */
  ZOO_DLL_EXPORT int FinalizeHPC(maps*& conf,maps*& inputs,maps*& outputs){
    // Retrieve the jobid corresponding to the identifier generated by SLURM
    // by reading the file generated when running the SBATCH file
    map* jobid=getMapFromMaps(inputs,"jobid","value");
    struct sockaddr_un addr;
    char buf[100]="3";
    int fd,rc=NULL;
    int i=0;
    SSHCON *test=ssh_connect(conf);
    if(test==NULL){
      return SERVICE_FAILED;
    }
    map* usid=getMapFromMaps(conf,"lenv","usid");
    map* tmpPath=getMapFromMaps(conf,"main","tmpPath");
    char *logPath=(char*)malloc((strlen(tmpPath->value)+strlen(jobid->value)+12)*sizeof(char));
    sprintf(logPath,"%s/exec_out_%s",tmpPath->value,jobid->value);
    struct stat f_status;
    int ts=stat(logPath, &f_status);
    char* fcontent = NULL;
    if(ts==0) {
      fcontent=(char*)malloc(sizeof(char)*(f_status.st_size+1));
      FILE* f=fopen(logPath,"rb");
      fread(fcontent,f_status.st_size,1,f);
      int fsize=f_status.st_size;
      fcontent[fsize]=0;
      fclose(f);
    }else{
      setMapInMaps(conf,"lenv","message",_("No service with this jobid can be found"));
      return SERVICE_FAILED;
    }
    free(logPath);
    // Run scontrol to see if the service execution ends
    // Store all the informations returned by scontrol command as a cfg file to
    // be parsed back by the ZOO-Kernel waiting for the execution of the remote
    // service
    maps* tmpMaps=createMaps("henv");
    char* command=(char*)malloc((126)*sizeof(char));
    //memset(&command,0,34);
    sprintf(command,"scontrol show jobid | grep -A24 %s",fcontent);    
    if(ssh_exec(conf,command,ssh_get_cnt(conf))==0){
      free(command);
      setMapInMaps(conf,"lenv","message",_("Failed to run scontrol remotely"));
      return SERVICE_FAILED;
    }else{
      free(command);
      logPath=(char*)malloc((strlen(tmpPath->value)+strlen(usid->value)+11)*sizeof(char));
      sprintf(logPath,"%s/exec_out_%s",tmpPath->value,usid->value);
      int ts=stat(logPath, &f_status);
      if(ts==0) {
        fcontent=(char*)malloc(sizeof(char)*(f_status.st_size+1));
        FILE* f=fopen(logPath,"rb");
        fread(fcontent,f_status.st_size,1,f);
        int fsize=f_status.st_size;
        fcontent[fsize]=0;
        fclose(f);
        free(logPath);
        fprintf(stderr,"%s \n",fcontent);
        char *token, *saveptr;
        token = strtok_r (fcontent, " ", &saveptr);
        while (token != NULL)
          {
            //fprintf(stderr,"%s %d\n",token,__LINE__);
            char *token1, *saveptr1;
            char *tmpToken=strdup(token);
            token1 = strtok_r (tmpToken, "=", &saveptr1);
            int isNext=-1;
            int hasTwoElements=0;
            char *name=NULL;
            while (token1 != NULL)
              {
                if(hasTwoElements==0)
                  name=strdup(token1);
                if(hasTwoElements<1)
                  hasTwoElements+=1;
                else{
                  char *value=strdup(token1);
                  if(value[strlen(value)-1]=='\n')
                    value[strlen(value)-1]=0;
                  if(strlen(name)>0 && strlen(value)>0){
                    if(tmpMaps->content==NULL)
                      tmpMaps->content=createMap(name,value);
                    else
                      addToMap(tmpMaps->content,name,value);
                    free(value);
                  }
                  free(name);
                  hasTwoElements=0;
                }
                token1 = strtok_r (NULL, "=", &saveptr1);
              }
            free(tmpToken);
            token = strtok_r (NULL, " ", &saveptr);
          }
      }else{
        setMapInMaps(conf,"lenv","message",_("Unable to access the downloaded execution log file"));
        return SERVICE_FAILED;
      }
    }
    logPath=(char*)malloc((strlen(tmpPath->value)+strlen(usid->value)+15)*sizeof(char));
    sprintf(logPath,"%s/exec_status_%s",tmpPath->value,usid->value);
    dumpMapsToFile(tmpMaps,logPath,0);

    char *sname=(char*)malloc((strlen(tmpPath->value)+strlen(jobid->value)+21));
    sprintf(sname,"%s/.wait_socket_%s.sock",tmpPath->value,jobid->value);
    if ( (fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
      perror("socket error");
      setMapInMaps(conf,"lenv","message",_("Socket error"));
      return SERVICE_FAILED;
      }
    }
    logPath=(char*)malloc((strlen(tmpPath->value)+strlen(usid->value)+15)*sizeof(char));
    sprintf(logPath,"%s/exec_status_%s",tmpPath->value,usid->value);
    dumpMapsToFile(tmpMaps,logPath,0);
    char *sname=(char*)malloc((strlen(tmpPath->value)+strlen(jobid->value)+21));
    sprintf(sname,"%s/.wait_socket_%s.sock",tmpPath->value,jobid->value);
    if ( (fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
      perror("socket error");
      setMapInMaps(conf,"lenv","message",_("Socket error"));
      return SERVICE_FAILED;
    }
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, sname, sizeof(addr.sun_path)-1);
    if (connect(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
      perror("connect error");
      setMapInMaps(conf,"lenv","message",_("Unable to connect"));
      return SERVICE_FAILED;
    }
    if (write(fd, "3", 1) != rc) {
      if (rc < 0) {
        perror("write error");
        setMapInMaps(conf,"lenv","message",_("Unable to announce the successful execution of the HPC service"));
        close(fd);
        return SERVICE_FAILED;
      }
    }
    close(fd);
    setOutputValue(outputs,"Result",(char*)"\"FinalizeHPC run successfully\"",32);

    return SERVICE_SUCCEEDED;
  }

}
